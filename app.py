# -*- coding: utf-8 -*-
"""Cisc 121 project -1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mEnDnaKA9hRicfkGHKdbmBesb-z4h6Hc
"""

# app.py
"""
CISC-121 Project: Binary Search Visualizer
Author: <Your Name>
Description:
 - Interactive Gradio app that demonstrates Binary Search on a sorted integer list.
 - Features:
    * Generate a random sorted list (or enter a custom comma-separated list)
    * Run binary search showing each step (low, mid, high, comparison)
    * Input validation and helpful messages
    * Downloadable results / copyable output text for screenshots
"""

import random
from typing import List, Tuple, Optional

import gradio as gr

# ---------------------------
# Algorithm Implementation
# ---------------------------

def binary_search_with_steps(arr: List[int], target: int) -> Tuple[Optional[int], List[str]]:
    """
    Perform binary search and record each step for visualization.
    Returns:
      - index of found element (None if not found)
      - list of human-readable step descriptions
    """
    steps = []
    low = 0
    high = len(arr) - 1
    step_no = 1

    steps.append(f"Start: array length = {len(arr)}. Searching for {target}.\nArray: {arr}")

    while low <= high:
        mid = (low + high) // 2
        steps.append(
            f"Step {step_no}: low={low}, mid={mid}, high={high} -> compare target({target}) with arr[mid]({arr[mid]})"
        )
        if arr[mid] == target:
            steps.append(f"Found target {target} at index {mid}.")
            return mid, steps
        elif arr[mid] < target:
            steps.append(f"Target {target} > arr[mid]({arr[mid]}), so move low to mid+1 ({mid + 1}).")
            low = mid + 1
        else:
            steps.append(f"Target {target} < arr[mid]({arr[mid]}), so move high to mid-1 ({mid - 1}).")
            high = mid - 1
        step_no += 1

    steps.append(f"Target {target} not found in the array.")
    return None, steps

# ---------------------------
# Helper Utilities
# ---------------------------

def parse_custom_list(text: str) -> Tuple[Optional[List[int]], str]:
    """
    Parse a comma/space-separated string into a list of ints.
    Returns (list, error_message). If parsing fails, list is None and error_message is descriptive.
    """
    if text is None or text.strip() == "":
        return None, "Empty input."
    # allow commas, spaces; remove extra spaces
    separators = [",", " "]
    cleaned = text.replace(",", " ").strip()
    parts = [p for p in cleaned.split() if p != ""]
    nums = []
    for p in parts:
        try:
            nums.append(int(p))
        except ValueError:
            return None, f"Can't parse '{p}' as integer. Use integers separated by commas or spaces."
    return nums, ""

def generate_sorted_random_list(size: int, min_val: int = 0, max_val: int = 99) -> List[int]:
    """
    Generate a sorted list of `size` unique random integers between min_val and max_val.
    If size is larger than range, allow duplicates.
    """
    if size <= 0:
        return []
    rng = max_val - min_val + 1
    if size <= rng:
        arr = random.sample(range(min_val, max_val + 1), size)
    else:
        # duplicates needed; sample with replacement
        arr = [random.randint(min_val, max_val) for _ in range(size)]
    arr.sort()
    return arr

# ---------------------------
# Gradio App Functions
# ---------------------------

def on_generate_random(size: int, min_val: int, max_val: int):
    """
    Called when user clicks 'Generate Random Sorted List'.
    Returns the list as a string and no steps yet.
    """
    if size is None or size < 0:
        return "", "Invalid size. Enter a non-negative integer.", ""
    if min_val is None or max_val is None or min_val > max_val:
        return "", "Invalid min/max range.", ""
    arr = generate_sorted_random_list(size, min_val, max_val)
    arr_text = ", ".join(map(str, arr))
    return arr_text, "Random sorted list generated. Now enter a target and click Run Binary Search.", ""

def on_use_custom_list(custom_list_text: str):
    """
    Called when user wants to use the custom list typed in the input box.
    Validates and returns sorted list string (we sort automatically).
    """
    parsed, err = parse_custom_list(custom_list_text)
    if parsed is None:
        return "", f"Error parsing list: {err}", ""
    parsed_sorted = sorted(parsed)
    return ", ".join(map(str, parsed_sorted)), "Custom list accepted and sorted (ascending).", ""

def on_run_search(list_text: str, target_text: str):
    """
    Run binary search with steps using the current list text and target text.
    Return step-by-step output (multi-line string) and a short result summary.
    """
    # Validate list
    if list_text is None or list_text.strip() == "":
        return "Error: no array provided. Generate a list or enter a custom list first.", ""
    parsed, err = parse_custom_list(list_text)
    if parsed is None:
        return f"Error parsing array: {err}", ""
    arr_sorted = sorted(parsed)

    # Validate target
    if target_text is None or target_text.strip() == "":
        return "Error: no target provided. Enter an integer target to search for.", ""
    try:
        target = int(target_text.strip())
    except ValueError:
        return f"Error: target '{target_text}' is not a valid integer.", ""

    index, steps = binary_search_with_steps(arr_sorted, target)
    out_text = "\n".join(steps)
    if index is None:
        summary = f"Result: target {target} NOT FOUND in array of length {len(arr_sorted)}."
    else:
        summary = f"Result: target {target} FOUND at index {index} (0-based index)."
    return out_text, summary

# ---------------------------
# Gradio Interface
# ---------------------------

def build_ui():
    with gr.Blocks(title="Binary Search Visualizer") as demo:
        gr.Markdown(
            """
            # Binary Search Visualizer
            Learn how Binary Search works step-by-step on a sorted list of integers.
            - Generate a random sorted list, or paste a custom list (numbers separated by comma or space).
            - Enter the target value and click **Run Binary Search** to see each comparison and pointer movement.
            """
        )

        with gr.Row():
            with gr.Column(scale=2):
                gr.Markdown("## Array Input / Generation")
                size_input = gr.Number(label="Random list size", value=10, precision=0)
                min_input = gr.Number(label="Minimum value", value=0, precision=0)
                max_input = gr.Number(label="Maximum value", value=99, precision=0)
                btn_generate = gr.Button("Generate Random Sorted List")
                gr.Markdown("**Or** enter a custom list (commas or spaces):")
                custom_list = gr.Textbox(
                    label="Custom list (e.g. 3, 7, 12, 44 or 3 7 12 44)",
                    placeholder="Type numbers separated by commas or spaces"
                )
                btn_use_custom = gr.Button("Use Custom List (sort automatically)")
                arr_display = gr.Textbox(label="Current array (sorted)", interactive=False, lines=2)

            with gr.Column(scale=3):
                gr.Markdown("## Search")
                target_input = gr.Textbox(label="Target value (integer)", placeholder="e.g. 42")
                btn_search = gr.Button("Run Binary Search")
                output_steps = gr.Textbox(label="Step-by-step output", lines=18, interactive=False)
                result_summary = gr.Textbox(label="Summary Result", lines=1, interactive=False)

        # Bind events
        btn_generate.click(
            on_generate_random,
            inputs=[size_input, min_input, max_input],
            outputs=[arr_display, result_summary, output_steps],
        )

        btn_use_custom.click(
            on_use_custom_list,
            inputs=[custom_list],
            outputs=[arr_display, result_summary, output_steps],
        )

        btn_search.click(
            on_run_search,
            inputs=[arr_display, target_input],
            outputs=[output_steps, result_summary],
        )

        gr.Markdown(
            """
            **Notes:** indices are 0-based. The visual output lists internal steps taken by the binary search algorithm.
            """
        )

        # Theme: soft (optional). You can change theme choices if desired.
        # demo.launch(server_name="0.0.0.0", share=True)  # used for local debugging sometimes
        return demo

if __name__ == "__main__":
    demo_app = build_ui()
    # Choose a soft theme for a nice look on Hugging Face Spaces; comment out if using local desktop.
    demo_app.launch(share=True)